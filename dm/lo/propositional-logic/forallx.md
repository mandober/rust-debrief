# forallx

## Intro

Formal languages
- `SL`, Sentential (Propositional) logic
- `QL`, Quantified (Predicate) logic

In SL, the smallest units are statements represented as letters and connected with logical connectives to make more complex statements.

In QL, the basic units are objects, properties of objects, and relations between objects.

We would like a formal language that allows us to represent many kinds of English language arguments. This is one reason to prefer QL to Aristotelean logic; QL can represent every valid argument of Aristotelean logic and more.


## Sentential logic

We make the assumption that true and false are the only possible truth-values. Logical languages that make this assumption are called **bivalent**, which means two-valued. Aristotelean logic, SL, and QL are all bivalent, but there are limits to the power of bivalent logic.

For instance, some philosophers have claimed that the future is not yet determined. If they are right, then sentences about what will be the case are not yet true or false. Some formal languages accommodate this by allowing for sentences that are neither true nor false, but something in between. Other formal languages, so-called paraconsistent logics, allow for sentences that are both true and false.


### Summary of logical notions

- An **argument** is (deductively) **valid** if it is impossible for the premises to be true and the conclusion false; it is invalid otherwise.
- A **tautology** is a sentence that must be true, as a matter of logic.
- A **contradiction** is a sentence that must be false, as a matter of logic.
- A **contingent sentence** is neither a tautology nor a contradiction.
- Two sentences are **logically equivalent** if they necessarily have the same truth value.
- A set of sentences is **consistent** if it is logically possible for all the members of the set to be true at the same time; it is inconsistent otherwise.


When we talk about a language, the language that we are talking about is called the **object language**. The language that we use to talk about the object language is called the **metalanguage**.


Formal definition for a well-formed formula of SL:
1. Every atomic sentence is a wff.
2. If A is a wff, then ¬A is a wff of SL.
3. If A and B are wffs, then (A ∧ B) is a wff.
4. If A and B are wffs, then (A ∨ B) is a wff.
5. If A and B are wffs, then (A → B) is a wff.
6. If A and B are wffs, then (A ⇔ B) is a wff.
7. All and only wffs of SL can be generated by applications of these rules.

A sentence is a meaningful expression that can be true or false. Since the meaningful expressions of SL are the wffs and since every wff of SL is either true or false, the definition for a sentence of SL is the same as the definition for a wff. Not every formal language will have this nice feature, e.g. there are wffs in QL which are not sentences.

The recursive structure of sentences in SL will be important when we consider the circumstances under which a particular sentence would be true or false. The sentence ¬¬¬D is true iff the sentence ¬¬D is false, and so on through the structure of the sentence until we arrive at the atomic components: ¬¬¬D is true iff the atomic sentence D is false.

### Notational conventions
A wff like (Q ∧ R) must be surrounded by parentheses, because we might apply
the definition again to use this as part of a more complicated sentence. So, strictly speaking, Q ∧ R without parentheses is not a sentence of SL, although this might be relaxed when unambiguous. The same goes for A ∧ B ∧ C, which isn't a sentence, but a kind of shorthand, written as such for the sake of convenience instead of the strict form (A ∧ (B ∧ C)).

### Truth-functional connectives
The truth-value of the compound sentence depends only on the truth-value of the atomic sentences that comprise it. In order to know the truth-value of, e.g. 
(D ∧ E), you only need to know the truth-value of D and E. Connectives that work in this way are called **truth-functional**.

---

## QUANTIFIED LOGIC

A logical language QL is a version of quantified logic, because it allows for quantifiers like `all` and `some`. Quantified logic is also sometimes called predicate logic, because the basic units of the language are predicates and terms.


### From sentences to predicates
Generally, if an argument containing quantifiers comes out valid in SL, then the English language argument is valid. If it comes out invalid in SL, then we cannot say the English language argument is invalid. The argument might be valid because of quantifier structure which the natural language argument has and which the argument in SL lacks.

Similarly, if a sentence with quantifiers comes out as a tautology in SL, then the English sentence is logically true. If it comes out as contingent in SL, then this might be because of the structure of the quantifiers that gets removed when we translate into the formal language.

In order to symbolize arguments that rely on quantifier structure, we need to develop a different logical language - Quantified Logic (QL).

### Building blocks of QL
Just as sentences were the basic unit of sentential logic, predicates will be the basic unit of quantified logic.

A predicate is an expression like "is a man". This is not a sentence on its own and it is neither true nor false. In order to get a truth value we need to specify a subject this predicate is related to.

In QL, we will represent predicates with capital letters.
We will use lower-case letters as the names of specific things.

For instance, we might let s stand for Spotty and D stand for "is a dog". The expression `Ds` will be a sentence in QL. It is a translation of the sentence "Spotty is a dog".


#### Singular terms
- A proper name is a singular term that picks out an individual without describing it.
- A definite description picks out an individual by means of a unique description.
- singular terms in QL must refer to just one specific thing
- In QL, we symbolize singular terms with (subscripted) lower-case letters `a-w`
- Singular terms are **constants**, they pick out specific individuals
- **variables**, `x,y,z,...`, do not stand for any specific thing.
- they are not constants, we need them to introduce quantifiers.


#### Predicates
- The simplest predicates are properties of individuals.
- **1-place** or **monadic** predicates require a single term.
- A one-place predicate and a singular term combine to make a sentence.
- **2-place** or **dyadic** predicates are about relation between 2 things.
- they need to be filled in with 2 terms in order to make a sentence.
- **3-place** or **triadic** predicates are about relation between 3 things.
- they need to be filled in with 3 terms in order to make a sentence.

For instance, when translating a sentence: "_A borrowed B from C_" to QL, which predicate should we use? If discussion is limited to different B terms (to the thing being borrowed), the generality of the 3-place predicate is unnecessary. If discussion is limited to different A terms (that borrowed something from C), then a 1-place predicate is enough.

- In general, we can have predicates with as many places as we need.
- Predicate with more than 1 place are called **polyadic**.
- Predicates with `n` places are called **n-place** or **n-adic**.
- Predicates use capital letters `A-Z` in QL, with or without subscripts.


#### Quantifiers

- `∀` symbol is the **universal quantifier**
- `∃` symbol is the **existentioal quantifier**
- quantifier must be followed by a variable and formula that includes that var.
- formula that follows the quantifier is called the **scope of the quantifier**.
- scope is the part of the sentence that the quantifier quantifies over.
- In `∀xHx`, the scope of the universal quantifier is `Hx`
- the `x` is serving as a kind of placeholder.
- The expression `∀x` means anything can be put as `x`.
- The letter `x` used for var name is not special, might've been `y`.
- logically equivalent: `∀xAx ≡ ¬∃x¬Ax`
- In SL, `A → B` is logically equivalent to `¬A ∨ B` and this also holds in QL.
- ∀ usually goes with a conditional, ∃ does not



#### QL: Example translations

Keys:
- `Hx` : _x is happy_
- `Txy`: _x is as tough or tougher than y_
- `d`: _Donald_
- `g`: _Gregor_
- `m`: _Marybeth_

Translations:

"_Everyone is happy_" can be paraphrased as 
"_For all x, x is happy_", and symbolized as 
`∀xHx`.

"_Everyone is at least as tough as Donald_" can be paraphrased as 
"_For all x, x is as tough or tougher than Donald_" and symbolized as 
`∀xTxd`

"_Someone is angry_" can be paraphrased as 
"_There is **some** x which is angry_" or, more precisely, as 
"_There is **at least one** x which is angry_" and symbolized as 
`∃xAx`

"_No one is angry._" can be paraphrased as 
"_It is not the case that someone is angry_" 
and symbolized as `¬∃xAx`
or paraphrased as "_Everyone is not angry_"
and symbolized as `∀x¬Ax`


#### Universe of Discourse

In order to eliminate ambiguity, we will need to specify a universe of
discourse, abbreviated UD. The UD is the set of things that we are talking
about. The quantifiers range over the universe of discourse.

In QL, the UD must be non-empty; that is, it must include at least one thing.
It is possible to construct formal languages that allow for empty UDs, but this
introduces complications. Even allowing for a UD with just one member can produce some strange results.

This is the problem of **non-referring terms** - each constant of QL must refer to something in the UD, although the UD can be any set of things that we like.


#### QL: Example translations

English sentences:
14. Every coin in my pocket is a quarter: `∀x(Px → Qx)`
15. Some coin on the table is a dime: `∃x(Tx ∧ Dx)`
16. Not all the coins on the table are dimes: 
17. None of the coins in my pocket are dimes: 

Keys:
- Universe of Discourse
  - UD: "all coins that exist"
- Predicates:
  - Px: "x is in my pocket"
  - Tx: "x is on the table"
  - Qx: "x is a quarter"
  - Dx: "x is a dime"


**S14**     
"_Every coin in my pocket is a quarter_"     
is most naturally translated with ∀, which holds for everything in UD (not just for my pocket and the coins therein). Using conjunction to connect the predicates would yield `∀x(Px ∧ Qx)`, which is not correct and means something different.

`∀x(Px ∧ Qx)` means:
```
∀x      everything (for all) in UD (i.e. all existing coins)
(       is
  Px    in my pocket
  ∧     AND
  Qx    a quarter (being a quarter, identified as a quarter)
)
```
So, "all existing coins are in my pocket and a quater" is not right.

Paraphrasing it using an implication, 
"_for any coin: if it is in my pocket, then it is a quarter_" 
yields the right translation: `∀x(Px → Qx)`.

In SL and QL, `A → B` is logically equivalent to `¬A ∨ B`:    
`∀x(Px → Qx) ≡ ∀x(¬Px ∨ Qx)`
"_for any coin: either it is NOT in my pocket OR it is a quarter_"


**S15**     
If we try to translate S15 using an ∃ and a conditinal for connecting the predicates, we get: `∃x(Tx → Dx)`, which means that there is a member of UD satisfying the subformula i.e. there exists an `a` such that `(Ta → Da)` is true. This says "There exists some coin such that, if it is on the table, then it is a dime". Since `A → B` is logically equivalent to `¬A ∨ B`, we can test the resulting formula: `∃x(Tx → Dx)` is true if there is some `a` such that `(¬Ta → Da)` i.e. it is true if some coin is NOT on the table OR it is a dime. Of course, there exists a coin that isn't on the table - there's coins in plenty other places (like my pockets for one), and they are dimes. So `∃x(Tx → Dx)` is trivially true.

We needed to use a conditional with the universal quantifier, but a conjunction with the existential quantifier.

can be translated using ∃ and conjunction to connect the predicates. To say that "_THERE EXIST a coin which is on the table AND which is a dime_", we can write: `∃x(Tx ∧ Dx)`.


**A conditional will usually be the natural connective to use with ∀**.

A conditional within the scope of ∃ can do very strange things - as a general rule, _do not put conditionals in the scope of ∃_ unless you are sure you really need to.

...(to be completed)


---

## Sentences of QL

**QL Expressions**

There are 6 kinds of symbols in QL:
- predicates: $$A,B,C,\ldots,Z$$ (with subscripts, if needed)
- constants: $$a,b,c,\ldots,z$$ (with subscripts, if needed)
- variables: $$x,y,z,\ldots$$ (with subscripts, if needed)
- connectives: ¬ ∧ ∨ → 
- quantifiers: ∃ ∀
- parentheses

We define an expression of QL as any string of symbols of QL.
Take any of the symbols of QL in any order, and that's a QL expression.


**Well-formed formulae**

- By definition, a term of QL is either a constant or a variable.
- An atomic formula of QL is an n-place predicate followed by n terms.
- Every atomic formula is a wff, build new wffs with connectives.
- In order for $$\forall x \varphi$$ to be a wff, $$\varphi$$ must contain the variable $$x$$ and must not already contain an $$x$$-quantifier.

1. Every atomic formula is a wff.
2. If $$\varphi$$ is a wff, then $$\lnot \varphi$$ is a wff.
3. If $$\varphi$$ and $$\psi$$ are wffs, then ($$\varphi \land \psi$$), is a wff.
4. If $$\varphi$$ and $$\psi$$ are wffs, ($$\varphi \lor \psi$$) is a wff.
5. If $$\varphi$$ and $$\psi$$ are wffs, then ($$\varphi \to \psi$$) is a wff.
6. If $$\varphi$$ and $$\psi$$ are wffs, then ($$\varphi \iff \psi$$) is a wff.
7. If $$\varphi$$ is a wff, $$\chi$$ is a variable, $$\varphi$$ contains at least one occurrence of $$\chi$$, and $$\varphi$$ contains no $$\chi$$-quantifiers, then $$\forall \chi \varphi$$ is a wff.
8. If $$\varphi$$ is a wff, $$\chi$$ is a variable, $$\varphi$$ contains at least one occurrence of $$\chi$$, and $$\varphi$$ contains no $$\chi$$-quantifiers, then $$\exists \chi \varphi$$ is a wff.
9. All wffs of QL can be generated by applications of these rules.

The $$\chi$$ that appears in the definitions is not a variable x, but a meta-variable that stands in for any variable of QL.

> The scope of a quantifier is the subformula for which the quantifier is the main logical operator.

**Sentences**

- A sentence is something that can be either true or false.
- In SL, every wff was a sentence, but this is not the case in QL.
- Quantifier tells us how to interpret a variable.
- The scope of x-quantifier is the part of formula where the quantifier tells how to interpret x.
- **Bound variable** is an occurrence of a variable $$\chi$$ that is within the scope of an $$\chi$$-quantifier.
- **Free variable** is an occurance of a variable that is not bound.
- **Sentence** is a wff that contains no free variables.


---

## SL Semantics

- The **object language** is the language that we are talking about (SL, QL)
- We use **metalanguage** to talk about the object language (English)
- Truth in SL just is the assignment of a 1 or a 0.

To formally define truth in SL, then, we want a function, $$v$$ (for "valuation"), that assigns a 1 or 0 to each of the sentences of SL.

We can interpret this function as a definition of truth for SL if it assigns 1 to all of the true sentences of SL and 0 to all of the false sentences of SL.

We want $$v$$ to be a function such that for any sentence $$A$$, $$v(A) = 1$$ if $$A$$ is true and $$v(A) = 0$$ if $$A$$ is false.

Our strategy for defining the truth function, v, will also be in two steps. The first step will handle truth for atomic sentences; the second step will handle truth for compound sentences.

