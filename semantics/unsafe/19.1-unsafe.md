# Unsafe Rust

https://doc.rust-lang.org/book/second-edition/ch19-01-unsafe-rust.html

`unsafe` allows access to these 4 features, disabling memory safety checks:
1. Dereferencing a raw pointer
2. Calling an unsafe function or method
3. Accessing or modifying a mutable static variable
4. Implementing an unsafe trait


## 1. Dereferencing a raw pointer
- Unsafe Rust has 2 new types, similar to refs, called *raw pointers*.
- We can have an immutable `*const T` and mutable `*mut T` raw pointer.
- In the context of raw pointers, immutable means that the pointer canâ€™t be
  directly assigned to after being dereferenced.
- *safe to create* raw pointers, *unsafe to dereference*.
- Using dereference operator `*` on a raw pointer requires an unsafe block

## 2. Calling an unsafe functions or methods
- Unsafe fns look exactly like regular do, but they have `unsafe` keyword prefixed. 
- Bodies of unsafe fns are effectively unsafe blocks.
- Functions declared within `extern` blocks are always unsafe
- `extern` functions provide Foreign Function Interface (FFI) for calling fns
  in other langs and for other langs to call Rust fns.

## 3. Accessing or modifying a mutable static variable
- global variables are called `static` variables in Rust
- The name of static var is in SCREAMING_SNAKE_CASE by convention
- The type of static var must be annotated
- Only references with the `'static` lifetime may be stored in a static var.
- Accessing immutable static variables is safe.
- Accessing or modifying mutable static variables is unsafe.

## 4. Implementing an unsafe trait
- declare that a trait is unsafe by adding the `unsafe` keyword before trait
- impl unsafe trait must be marked as `unsafe` too
